**Updated: 2025-07-05** - This blueprint has been updated to reflect the clarified project requirements, including simplified geofencing and the use of Expo Modules API.

---

# DAMS Geotracking & Geofencing – SDK Implementation Blueprint

**Document ID:** GT-BP-1.1  **Last Reviewed:** 2025-07-05  **Author:** Mobility Platform Team

---

## 1 Purpose & Scope

This blueprint is the authoritative technical reference for the DAMS Geotracking & Geofencing SDK. It defines the architecture and implementation of a self-contained, high-performance native module for React Native applications using Expo development builds.

This document serves as the canonical guide for development, testing, and maintenance of the SDK. The SDK provides location tracking with user-defined off-limits zones for safety warnings, designed as a standalone module for React Native projects.

## 2 High-Level Architecture

```
React Native Host App
 └── LocationProviderContext (TypeScript)
      └── DAMS Geo SDK (NPM Package)
           ├── Expo Modules API
           │     ├── GeofenceEngine
           │     └── TrackingEngine
           └── DataLayer (Repository)
                  └── SQLCipher DB (op-sqlite) – encrypted
```

- **SDK Packaging:** The module will be built and distributed as a private NPM package using Expo Modules API.
- **Native Layer:** Core logic is implemented in Swift (iOS) and Kotlin (Android) using the Expo Modules API for optimal developer experience and performance.
- **API Bridge:** The Expo Modules API provides native performance through its internal JSI implementation, exposing the required public methods.
- **Database:** All persisted location data is stored in an on-device SQLCipher-encrypted SQLite database using `op-sqlite` with WAL mode enabled for high-concurrency performance.

## 3 Security & Encryption

### 3.1 SQLCipher Integration

- **Initialization:** Replace standard `sqlite3_open_v2()` calls with `sqlite3_open_v3()` followed by `PRAGMA key = '...'` to enable 256-bit AES-CBC encryption.
- **Compiler Flags:** The native module will be compiled with flags: `-DSQLITE_HAS_CODEC` and `-DSQLCIPHER_CRYPTO_OPENSSL`.
- **WAL Encryption:** Encrypted Write-Ahead Logging will be enabled for performance and security using `PRAGMA cipher_use_hmac = ON;` and `PRAGMA journal_mode = WAL;`.

### 3.2 Key Management

| Item                  | Decision                                                                                                                                                                                                                                                                          |
| :-------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Key Generation**    | A cryptographically secure 256-bit random key is generated by the native module on its first initialization for a given user.                                                                                                                                                     |
| **Storage (iOS)**     | The key is stored as a Keychain item with class `kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly`. Access is gated by the Secure Enclave where available.                                                                                                                        |
| **Storage (Android)** | A master key is created in the Android Keystore (AES-256-GCM). The SQLCipher database key is encrypted with this master key and the resulting ciphertext is stored in `SharedPreferences`.                                                                                        |
| **Rotation**          | Key rotation is triggered by an explicit "Secure Logout" action in the host app or upon app reinstallation. A Secure Logout must trigger an SDK function that wipes the database, the SQLCipher key from `SharedPreferences`, and the master key alias from the Android Keystore. |
| **Backup**            | Keychain items will be configured to _not_ sync to iCloud (`kSecAttrSynchronizable` = false). The Android Keystore alias will be configured to use StrongBox for hardware-backed security when available.                                                                         |

### 3.3 Device Integrity Verification (Android)

To mitigate threats on compromised devices, an additional security layer will be implemented on Android:

1.  **Detection:** On SDK initialization, the module will use the **Play Integrity API** to assess device integrity. A fallback, library-based root detection mechanism will be used if Google Play Services are unavailable.
2.  **Action:** If the integrity check returns a `MEETS_DEVICE_INTEGRITY` failure (indicating root access, emulators, or other compromises), the SDK will refuse to initialize its cryptographic components. It will immediately wipe any existing Keystore alias and encrypted key from `SharedPreferences` and signal a fatal, non-recoverable error to the JavaScript layer.

### 3.4 Performance Budget

- **Requirement:** Maintain < 5 ms median write latency and < 5 % CPU utilization for batched writes at a 10 Hz frequency.
- **Method:** A CI-based benchmark will execute a workload of 50,000 `INSERT` statements (in batches of 20) and fail the build if latency regression exceeds 10% compared to a plaintext SQLite baseline.

## 4 Simplified Geofence Management (≤ 10 Active)

### 4.1 Requirements

- The SDK supports up to 10 user-defined off-limits zones.
- Users draw polygons on a map to define areas they want to avoid.
- The system provides warnings when users enter these zones.
- Simple on/off toggle for geofencing functionality.

### 4.2 Implementation Approach

1. **Zone Definition**: Users draw polygons on React Native Maps to define off-limits areas.
2. **Storage**: Polygon coordinates are stored in the local database.
3. **Monitoring**: All zones (max 10) are monitored simultaneously - no paging needed.
4. **Detection**: 
   - Convert polygons to circular regions for native geofence APIs where possible
   - Use point-in-polygon algorithm for precise boundary detection
5. **Warnings**: When user enters an off-limits zone, trigger warning notification.

- **Simplification Benefits**: No complex paging algorithm, no hysteresis calculations, straightforward implementation.
- **User Control**: Users have complete control over their safety zones with intuitive map-based interface.

### 4.3 State Machine

The geofencing engine operates on a formal state machine to manage transitions and events precisely.

- **States:**
  - `IDLE`: No tracking or geofence monitoring is active. The default state.
  - `MONITORING`: Actively tracking location and evaluating zones. Generates `enter` and `exit` events.
  - `WARNING`: The user has entered an off-limits zone and warning is active.
- **Transitions:**
  - `startTracking()` → `MONITORING`
  - `stopTracking()` → `IDLE`
  - _In `MONITORING`_: `onEnterZone()` → Fire `enter` event to JS, transition to `WARNING`.
  - _In `WARNING`_: `onExitZone()` → Fire `exit` event, transition to `MONITORING`.
  - _Any State_: `CriticalBattery` → Transition to a low-power state, reducing update frequency.

### 4.4 Failure Handling

- OS-level geofence registration failures will be retried with an exponential back-off strategy (2s, 8s, 30s, 2m, 30m).
- After 5 consecutive failures for a single fence, the SDK will mark it as "failed" and emit a fatal error to the JS layer with the fence ID and error details.

## 5 Activity Recognition & Tracking Engine

### 5.1 Provider Hierarchy

The SDK intelligently selects the best location provider to balance accuracy and battery consumption.

1.  **High-Level Activity API:** Google Play Services `ActivityRecognitionClient` / iOS `CMMotionActivityManager` are the primary sources for determining user state (e.g., stationary, walking, in_vehicle).
2.  **Raw Accelerometer Heuristic:** If high-level APIs are unavailable or slow to update, a low-level accelerometer heuristic serves as a fallback.
3.  **Distance-Based Polling:** As a final fallback, the system uses simple distance-based polling.

### 5.2 Accelerometer Heuristic

This heuristic provides reactive state changes without waiting for the OS.

- **Methodology:** The native module samples the raw accelerometer at 10 Hz and calculates the Root Mean Square (RMS) of the vector magnitudes over a sliding window.
- **Thresholds (Empirically Derived Defaults):**
  - **Moving:** RMS > 0.05 g over a 3-second window. This value is a common baseline for detecting intentional movement beyond device jitter.
  - **Stationary:** RMS < 0.02 g over a 30-second window. The longer window confirms the user has truly stopped and is not just pausing briefly.
- **Note:** These thresholds are configurable defaults and may require field testing and tuning for optimal performance across various devices.

### 5.3 iOS Background Location Tracking

- **Significant Location Changes**: Configured for 30-50m movement detection
- **Background Limitations**: App can be suspended unpredictably (10s to hours) when in background
- **Force Quit**: No tracking possible when user force-quits app (iOS design limitation)
- **Mitigation Strategies**:
  - Use significant location changes API
  - Implement region monitoring for geofences
  - Silent push notifications as backup wake mechanism
  - Clear user expectations about limitations

### 5.4 Adaptive Intervals & State Damping

The SDK adjusts location update frequency and accuracy based on the detected state.

| State          | Accuracy | Interval |
| :------------- | :------- | :------- |
| **Stationary** | 100 m    | 10 min   |
| **Walking**    | 25 m     | 60 s     |
| **Vehicle**    | 10 m     | 15 s     |

To prevent jarring interval changes (e.g., from 15s to 10m on a short traffic stop), a **state damping** mechanism will be used. When transitioning from a high-frequency state (`Vehicle`) to `Stationary`, the SDK will temporarily use the `Walking` interval (60s) for 2-3 minutes before fully backing off to the 10-minute `Stationary` interval.

## 6 Foreground Service UX (Android)

- **Channel ID:** `dams_location_service` with `IMPORTANCE_LOW` to minimize user interruption.
- **Collapsed View:** A persistent, non-dismissible notification with icon `ic_location_outline` and text "DAMS location active".
- **Android 14+ Requirements**: Must declare `foregroundServiceType="location|dataSync"` and show notification within 10 seconds.
- **Expanded View:**
  1.  Primary Text: "Your location is being used for safety alerts."
  2.  Action Button: "Pause 30 min" - This action stops the service and schedules a precise restart using `AlarmManager`.
  3.  Action Button: "Learn More" - This action deep-links to a relevant informational screen (e.g., `/about/location`) in the host app.
- **OEM Policy Compliance:** The notification must display a status bar icon even when collapsed to comply with Android policies.

## 7 Database Schema

### 7.1 Tables

```sql
CREATE TABLE geofence_zones (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  name TEXT,
  polygon_coords TEXT, -- JSON array of coordinates
  is_active BOOLEAN DEFAULT true,
  created_at INTEGER NOT NULL
);
CREATE INDEX idx_geofences_user ON geofence_zones(user_id);

CREATE TABLE location_log (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,
  lat REAL NOT NULL,
  lon REAL NOT NULL,
  accuracy REAL,
  speed REAL,
  activity_type TEXT NOT NULL, -- 'stationary', 'walking', 'vehicle', etc.
  ts INTEGER NOT NULL
);
CREATE INDEX idx_location_ts ON location_log(ts);
```

### 7.2 Data Retention Policy

A robust background job will purge `location_log` entries older than 30 days.

- **Mechanism:** The job will be scheduled using platform-native, battery-aware APIs.
  - **Android:** `WorkManager` with constraints (`NETWORK_TYPE_UNMETERED`, `DEVICE_IDLE`) to run opportunistically during optimal conditions (e.g., nightly charging).
  - **iOS:** `BGAppRefreshTask` to request background processing time from the OS for periodic database maintenance.

## 8 Multi-Profile Support

- The `user_id` column on all tables ensures data is partitioned per user.
- A `logout(userId)` function will delete all rows associated with that `userId`. The database file and its encryption key remain on the device to allow for offline continuity if another user logs in.

## 9 Audit Export Function

The SDK provides a secure function to export a user's location history.

- **Function:** `exportAudit(userId, from, to)` → returns a Promise resolving to the path of a `.geoexport` file.
- **Process:**
  1.  Generate an ephemeral AES-GCM key.
  2.  Query and dump the relevant `location_log` rows for the user.
  3.  Encrypt the data dump with the ephemeral key.
  4.  Fetch the user's private RSA-2048 key from the Keystore/Keychain.
  5.  Sign a manifest containing the data hash and ephemeral key with the private key.
  6.  Package the encrypted data and signed manifest into a single archive.

### 9.1 Public Key Management

To enable external verification of the audit export, the user's public key must be accessible to a backend service.

- **Strategy:** Upon generation of the RSA key pair, the SDK will upload the public key to a designated cloud endpoint.
- **Implementation Example:** A **Supabase Edge Function** will be used as the endpoint. The function will require a valid user JWT (from Supabase Auth) for authorization. It will then store the provided public key in a `user_public_keys` table, mapping it to the authenticated `user_id`. The decryption/verification tool can then fetch this public key to verify the audit log's signature.

## 10 Public API (Expo Modules)

| Method                  | Sync? | Return            | Description                                                                                  |
| :---------------------- | :---- | :---------------- | :------------------------------------------------------------------------------------------- |
| `startTracking()`       | no    | `Promise<void>`   | Initializes engines and begins adaptive location updates.                                    |
| `stopTracking(reason)`  | no    | `Promise<void>`   | Stops all tracking and geofencing activity.                                                  |
| `setGeofences(list)`    | yes   | `void`            | Sets the list of off-limits zones (max 10).                                                 |
| `on(event, cb)`         | —     | `Subscription`    | Subscribes to an event (`enter`, `exit`, `error`). Returns a `Subscription` object.          |
| `Subscription.remove()` | yes   | `void`            | Unsubscribes the listener associated with the subscription object.                           |
| `getCurrentActivity()`  | yes   | `string`          | Returns current activity type (stationary/walking/vehicle/unknown).                          |
| `isTracking`            | —     | `boolean`         | Property indicating if tracking is active.                                                   |
| `exportAudit(...)`      | no    | `Promise<string>` | Asynchronously creates a secure audit log and resolves with the file path.                   |

## 11 Testing Strategy

- **JS Unit Tests:** Jest with mocked Expo Modules; target ≥ 90% line coverage for the TypeScript layer.
- **Native Unit Tests:** XCTest (iOS) and Robolectric (Android) for testing native logic (algorithms, state machines) in isolation.
- **E2E Tests:** Nightly test runs on Firebase Test Lab (Android) and Xcode Cloud (iOS) across a matrix of devices and OS versions, covering cold starts, reboots, and battery saver modes.
- **Performance Benchmarks:** A dedicated CI job will run the write latency benchmark (Sec 3.4) and fail the build on > 10% regression.

## 12 CI / CD Pipeline

1.  Lint & static analysis.
2.  JS & Native unit tests.
3.  Build SDK (EAS Build / Gradle / xcodebuild).
4.  Run E2E device tests.
5.  On success, package the SDK artifacts.
6.  Use `changesets` to manage versioning and publish the package to a private NPM registry.

## 13 Release & Maintenance

| Aspect          | Policy                                                                                                                     |
| :-------------- | :------------------------------------------------------------------------------------------------------------------------- |
| **Versioning**  | Semantic Versioning (SemVer). A compatibility matrix for React Native and Expo SDK versions will be maintained.            |
| **Deprecation** | The SDK will officially support the last 2 minor versions of React Native.                                                 |
| **Security**    | Critical CVEs in dependencies (e.g., SQLCipher, OpenSSL) will be patched and released within 30 days of public disclosure. |

## 14 Future Extensions

- Integration with BLE beacons for high-precision indoor positioning.
- On-device differential privacy layer for anonymized analytics aggregation.

## 15 Key Changes from Original Design

Based on clarified requirements, the following significant changes have been made:

1. **Geofencing Simplification**: Reduced from 100 zones with complex paging to 10 user-drawn zones
2. **API Implementation**: Using Expo Modules API instead of custom JSI implementation
3. **Development Approach**: All development uses Expo development builds (no Expo Go)
4. **Focus**: User safety zones rather than complex business geofencing logic
5. **Background Tracking**: Clear limitations acknowledged (no tracking when app is force-quit)

These changes significantly reduce complexity while maintaining all core functionality for user safety.

---

© 2025 DAMS Core Team.
